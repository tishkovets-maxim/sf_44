https://www.geeksforgeeks.org/plotting-multiple-bar-charts-using-matplotlib-in-python/


У нас есть таблица из X строк - ЗАПИСЕЙ.	// в нашем случае X == 4
Каждая запись включает N полей			// в нашем случае N == 3
	1 мы назначаем ключом,			// по идее можем и не 1. В датафрейме это индекс. На улице Герцена экономист
	N-1 называем просто "ПАРАМЕТРАМИ".	// т.е. у нас 2 параметра
Наборы одинаковых параметров всех записей образуют столбцы таблицы. Будем называть их рядами.
Ряд ключей назовем ИНДЕКСОМ.

ИНДЕКСУ на графике соответствует ОСЬ		// для графика вертикального - это ось x
ОСЬ делится на X отрезков, в каждом отрезке будет помещаться отдельная запись.
На каждом отрезке помещаются N-1 плашек, отображающих ПАРАМЕТРЫ.
	плашки могут ютиться бок о бок,
	либо громоздиться друг на друга

Матплотлибу, строго говоря, все равно, откуда берутся ряды.
Они вовсе не обязаны быть в рамках одной "физической" структуры.
Во всех примерах не создается никаких датафреймов, а просто задаются независимые массивы.
	// проверить - допускается ли в них вообще разное количество элементов
Этот момент - очень важен и может нам пригодиться.

А теперь начинаем вдумываться в пример


X = ['Group A','Group B','Group C','Group D']	# индекс. Будет показан метками на оси
Ygirls = [10,20,20,40]				# один РЯД параметров
Zboys = [20,30,25,30]				# второй РЯД параметров


X_axis = np.arange(len(X))			# массив целых чисел, по количеству ЗАПИСЕЙ
# вокруг него будет строиться размещение графиков. Обзовем его "СЕТКА".
  
plt.bar(X_axis - 0.2, Ygirls, 0.4, label = 'Girls')	# график по первому РЯДУ
plt.bar(X_axis + 0.2, Zboys, 0.4, label = 'Boys')	# график по второму РЯДУ

# plt.bar(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs)[source]

x - The x coordinates of the bars. See also align for the alignment of the bars to the coordinates.
	Откуда у нас будут торчать столбики данного графика
	Столбики первого графика будут у нас расти из позиции на 0.2 левее от СЕТКИ. X_axis - 0.2
	Второго графика - на 0.2 правее от СЕТКИ
height - 



height - The height(s) of the bars.





plt.xticks(X_axis, X)
plt.xlabel("Groups")
plt.ylabel("Number of Students")
plt.title("Number of Students in each group")
plt.legend()
plt.show()







12:16 2023/6/27
Как устроен матплотлиб


https://skacem.github.io/2021/08/23/Seaborn/
https://rus-linux.net/MyLDP/BOOKS/Architecture-Open-Source-Applications/Vol-2/matplotlib-02.html



1. Матплотлиб имеет 3 уровня.
* backend	"вывод данных" - внутреннее устройство
* artist	"рисование" - оперируем объектами этого уровня
* pyplot	"сценарий" - мы (отчасти) работаем тут


2.1. backend включает 3 основных класса (подробности и доп. детали нам счас не важны)
* FigureCanvas	"холст"		внутренняя реализация "бумаги" - определяет где мы действуем - Юпитер / пдф / рисунок / окно спец.приложения
* Renderer	"кисть"		внутренняя реализация создания графических объектов
* Event		обработка событий	прямо сейчас нам не нужна

2.2. artist - элементы графика.
* Primitive	примитивные	линия, прямоугольник, круг, текст
* Composite	составные	можно сказать, "функциональные" - Axis, Tick, Axes и т.д., и самое важное
Figure - это непосредственно объект "иллюстрация"
(тянет назвать его "графиком", но графиками было бы удобнее называть отдельные Axes в составе Figure)

2.3. pyplot
Его определяют как - интерфейс, позволяющий работать с объектно-ориентированным матплотлибом в процедурном стиле, как в Матлабе.

Суть такова. Модуль содержит некие механизмы определения контекста (в которых я сейчас не хочу разбираться) и при первом возможном случае создает объект Figure. Далее - вызываются функции, производящие те или иные манипуляции С ТЕКУЩИМ Figure

>In matplotlib.pyplot various states are preserved across function calls, so that it keeps track of things like the current figure and plotting area, and the plotting functions are directed to the current axes (please note that "axes" here and in most places in the documentation refers to the axes part of a figure and not the strict mathematical term for more than one axis).

Выделяют два "режима" или "интерфейса" работы с матплотлибом:
* explicit	явный		мы явным образом создаем figure, axes и далее врисовываем графики, меняем свойства уже к ним
* implicit	неявный		мы работаем pyplot и скрытые от глаз джинны применяют все, что мы делаем к **текущему** Figure
Выглядит это примерно так:

plt.axis([0,5,0,20])
	# запустили функцию из модуля pyplot. Она осмотрелась, не нашла в текущем контексте объекта Figure, создала.
	# и затем уже нормально отработала свое назначение - задала текущему Figure оси, как мы просим.
	# далее все операции применяются к тому же (нигде так и не упомянутому текущему Figure)
plt.title('My first plot', fontsize=20, fontname='Times New Roman')
plt.xlabel('Counting', color='gray')
plt.ylabel('Square values',color='gray')
plt.text(1,1.5,'First')
plt.text(2,4.5,'Second')
plt.text(3,9.5,'Third')
plt.text(4,16.5,'Fourth')
plt.plot([1,2,3,4],[1,4,9,16],'ro')
plt.show()	# в некоторых контекстах требуется явно просить "показать" все, что мы наменяли. Сейчас у меня в Юпитере - такого не требуется.

Фактически, чтобы не грузить лишних сущностей, запуск explicit режима тоже оформляется через pyplot:
import matplotlib.pyplot as plt
fig = plt.figure (figsize=(13,4))
А дальше уже орудуем по-объектному


3. Figure - центральный объект всего матплотлиба.
* все объекты уровня "артист" - входят в него как составные части
* объекты уровня backend - предназначены для отрисовки составных частей Figure и в итоге - его самого
* уровень pyplot - создает и держит в кармане этот же Figure




18:10 2023/6/27		Теперь про Сиборн

Сиборн есть настройка над матплотлибом.
Однако чего-то ради он дополнительно вводит свой собственный уровень "интерфейсов".
Функции Сиборна делятся на
* axes-level
* figure-level

# axes-level возвращает матплотлибовский axes
# Ей можно передавать матплотлибовский axes, тогда вернет его же с врисованным внутрь графиком


sns_axes = sns.barplot\
(   data = task_01_alt
    , y = 'event'
    , x = 'percent_to_max'
    , hue = 'tutorial_status'
    # , ax = axes[1]
)
sns_axes.__class__      # matplotlib.axes._axes.Axes


figure-level
# Возвращает собственные сиборновские объекты (возможны вариации, но по заявлению справки как правило это) FacetGrid
# Эти объекты ВНУТРИ СЕБЯ содержат отдельный Figure

sns_figure = sns.catplot\
(   data = task_01_alt
    , y = 'event'
    , x = 'percent_to_max'
    , hue = 'tutorial_status'
    , kind = 'bar'
)
sns_figure.__class__    # seaborn.axisgrid.FacetGrid

sns_figure.figure.__class__     # matplotlib.figure.Figure

sns_figure.axes.__class__   # numpy.ndarray
sns_figure.axes.shape   # (1, 1)
sns_figure.axes[0,0].__class__  # matplotlib.axes._axes.Axes


У него есть собственные СВОЙСТВА:
figure - возвращает непосредственно нормальный матплотлибовский Figure
axes - возвращает НУМПАЕВСКИЙ МАССИВ объектов Axes, в случае одного - тоже массив, размерностью (1 x 1)


20:24 2023/6/27
Зачем нужно такое казалось бы усложнение?

Оно нужно для удобного создания групп однотипных графиков

Например так:
g = sns.FacetGrid(tips, col="time",  row="sex")
g.map_dataframe(sns.histplot, x="total_bill")

Делаем "матрицу" из 4 одинаковых графиков.
"Столбцы" - время (в примере - обед / ужин), "Строки" - пол.
Структура каждого графика - x - total_bill, y - count

Или вот так:
sns.displot(data=penguins, x="flipper_length_mm", hue="species", col="species")

Тут у нас три гистограммы, для каждого из видов пингвинов (дополнительно - различаются цветом)

Это чрезвычайно круто.


    
        



21:30 2023/6/30
У Сиборна есть третий "интерфейс" - "объекты".
Он сравнительно новый и везде предупреждается, что экспериментальный,
Выглядит модно-стильно-молодежно, подозрительно высокоуровнево, но приятно.

Вообще уже предыдущие интерфейсы Сиборна, даже "осевой" делают работу куда приятнее, чем с голым матплотлибом.
В них можно реализовать какой-никакой чейнинг, как в пандах.

Однако я например немало пострадал от того, что чтобы сделать подписи к БАР-ам, даже не какие-то особые, а просто вообще подписи,
надо лезть в голый матплотлиб


